세그먼트: 트랜스포트 계층 패킷

### 다중화와 역다중화

TCP와 TDP에서 공통적으로 제공하는 기능

- 다중화: 출발지 호스트에서 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화하고, 그 세그먼트들을 네트워크 계층으로 전달하는 작업
- 역다중화: 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업

#### 비연결형 다중화와 역다중화

UDP: 소켓과 소켓 사이의 1:1 매핑 개념없음. 출발지 포트번호가 달라도 목적지 포트 번호가 같으면 같은 소켓을 통해 같은 프로세스로 향한다.

포트번호만 보고 식별함

- 출발지 포트 번호
- 목적지 포트 번호

#### 연결지향형 다중화와 역다중화

TCP 소켓은 4개 요소의 집합에 의해 식별된다.

- 출발지 IP 주소
- 출발지 포트 번호
- 목적지 IP 주소
- 목적지 포트 번호

## 비연결형 트랜스포트: UDP

#### UDP 세그먼트 구조

- Header (필드당 2바이트)
  - 출발지 포트 번호
  - 목적지 포트 번호
  - 길이
  - 체크섬
- 애플리케이션 데이터 (메시지)

#### UDP 체크섬

오류 검출을 위한 것. UDP는 오류 검사를 제공하지만, 오류를 회복하기 위한 어떤 일도 하지 않는다.
손상된 세그먼트를 버리거나 경고

## 신뢰적인 데이터 전송의 원리

#### 신뢰적인 데이터 전송 프로토콜의 구축

**rdt 1.0 - 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송**

- 오류 X
- 손실 X

송신측은 패킷을 보내고 수신측은 받음.
수신측이 송신측에게 어떤 피드백도 제공하지 않음

**rdt 2.0 - 비트 오류가 있는 채널상에서의 신뢰적 데이터 전송**

- 오류 O
- 손실 X

- 체크섬을 필드를 사용해 오류 검출.
- 수신측은 송신측에게 피드백 제공. 긍정 확인응답(ACK), 부정 확인응답(NAK)
- 송신측은 NAK를 받으면 데이터 재전송

**rdt 2.1**
ACK, ANK 패킷에서 오류가 있을 수 있다.

수신측에서 재전송된 메시지인지 새로운 메시지인지 모르기 때문에 순서 번호(sequence number) 삽입
수신측은 중복이든 아니든 무조건 피드백을 보냄.

**rdt 2.2**
NAK 빼고 ACK만 가지고 동작시킴
에러 받으면 ACK와 제대로 받은 마지막 시퀀스 넘버를 보냄

송신자는 제대로 된 ACK를 확인하지 못 하면 재전송한다.

**rdt 3.0 - 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송**

- 오류 O
- 손실 O

타이머를 추가해 ACK를 기다리는 시간을 제한하고 타이머가 끝나기 전에 ACK를 받지 못하면 패킷을 재전송

- 무손실 동작
- 패킷 손실
  - 시간 설정해놓고 그 안에 응답이 안 오면 재전송
- ACK 손실
  - 중복을 받았기 때문에 버리고 응답 보냄
- 조급한 타임아웃
  - 손실 아닌데 타임아웃으로 재전송됨. 응답 받으면 다음 패킷 전송

## 연결지향형 트랜스포트: TCP

- 연결지향형
- 전이중 서비스
- 점대점

### TCP 세그먼트 구조

- 출발지 포트 번호
- 목적지 포트 번호
- 순서 번호
- 확인응답 번호
- 수신 윈도, 체크섬, 플래그, ...

#### 순서 번호와 확인응답 번호

세그먼트에 대한 순서 번호는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호다.
ACK 번호는 수신측이 기대하는 다음 바이트의 순서 번호다.

### 왕복 시간(RTT) 예측과 타임아웃

샘플 RTT는 세그먼트가 송신된 시간으로부터 그 세그먼트에 대한 긍정응답이 도착한 시간까지의 길이다. 매번 세그먼트를 보낼때마다 측정.
재전송한 세그먼트에 대한 샘플 RTT는 계산하지 않는다.
샘플 RTT는 세그먼트마다 다르기 때문에 대체로 평균값을 채택한다.

`EstimateRTT = (1 - a) * EstimatedRTT + a * SampleRTT`

타임아웃 값은 EstimatedRTT에 약간의 여윳값을 더한 값으로 설정한다.

`TimeoutInterval = EstimatedRTT + 4 * DevRTT`

### 신뢰적인 데이터 전송

TCP에서는 한번에 보낼 수 있는 세그먼트의 제약이 있음 => 윈도 사이즈

- Send buffer: 재전송이 필요한 경우를 대비해 데이터 임시 저장. 재전송이 불필요하다고 확신되면 삭제
- Receive buffer: 수신 데이터를 순서대로 처리하기 장치로 사용된다.

**타이머 관리**
타이머는 여유있게 잡아서 유실에 대응하지만 느림.
동일한 ack가 연속 3번 유실되면 재전송

### 흐름 제어

송신자가 수신자의 버퍼를 오버플로시키는 것을 방지하기 위해 애플리케이션에게 흐름 제어 서비스를 제공한다.
헤더의 **수신 윈도(receive window)** 필드에 이 값을 포함시킴
수신 윈도는 수신 측에서 가용한 버퍼 공간이 얼마나 되는지 송신자에게 알려준다.

**특이 케이스**
수신 윈도가 0이고 상대에게 전송할 게 없을 경우, 상대 측에서 주기적으로 1바이트 데이터로 세그먼트를 계속해서 보낸다.

**Silly Window Syndrome**

애플리케이션이 생성하는 속도보다 네트워크 속도가 빠르면 세그먼트 사이즈 커지게되고, 반대면 세그먼트 사이즈가 작아진다. (Nagle의 알고리즘)

수신 윈도가 아주 작다면 0으로 보내서 비효율적인 세그먼트 줄이기

### TCP 연결 관리

TCP는 세 방향 핸드셰이크를 통해 연결한다.

**TCP 연결 설정**

1. 클라이언트 측에서 서버에 TCP SYN 세그먼트를 송신
2. 서버에서는 SYN ACK로 확인 응답
3. 클라이언트는 연결 승인 세그먼트를 수신하면 다시 확인 응답 (데이터 포함 가능)

**TCP 연결 종료**

- 애플리케이션 프로세스는 종료 명령 내리면 클라이언트 TCP가 서버 프로세스에게 FIN 비트를 포함한 세그먼트를 보냄
- 서버가 이 세그먼트를 수신하면 확인 응답
- 서버에서 FIN 비트가 1로 설정된 자신의 종료 세그먼트 송신
- 클라이언트는 이 세그먼트에 확인응답
- 두 호스트의 모든 자원 할당 해제

## 혼잡 제어의 원리

혼잡 원인 시나리오

1. 2개의 송신자와 무한 버퍼를 갖는 하나의 라우터
   - 패킷 도착률이 링크 용량에 근접함에 따라 큐잉 지연이 커진다.
2. 2개의 송신자, 유한 버퍼를 가진 하나의 라우터
   - 송신자는 버퍼 오버플로 때문에 버려진 패킷을 보상하기 위해 재전송을 수행해야한다.
   - 재전송으로 혼잡 상태 악화
3. 4개의 송신자와 유한 버퍼를 갖는 라우터, 그리고 멀티홉 경로
   - 혼잡 때문에 패킷을 버리면 버려지는 지점까지 패킷을 존상하는데 사용된 상위 라우터에서 사용된 전송 용량 낭비

## 혼잡 제어

혼잡 윈도(congestion window): 네트워크가 받아들일 수 있는 데이터 양

### 가법적 증가, 승법적 감소

세그먼트를 보내고 그거에 대한 피드백을 제대로 받으면 세그먼트 사이즈만큼 혼잡 윈도 사이즈를 늘림

- additive increase: RTT마다 cwnd 1MSS(Maximum Segment Size)씩 증가
- multiplicative decrease: 손실 발생 시 cwnd의 절반화

### 슬로 스타트

TCP 연결이 시작될 때 cwnd의 값은 1 MSS로 초기화
지수적으로 증가 하다가 slow start threshold부터 1씩 증가

유실 발생 시

1. 타임아웃 => cwnd를 1MSS로 설정하고 슬로 스타트 시작
2. 3개의 중복 ACK => cwnd를 1/2로 줄이고 1MSS씩 증가

### 공평성

TCP를 사용하는 K개의 연결이 각각 R/K를 가진다.
