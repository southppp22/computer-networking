## **2.1 네트워크 애플리케이션의 원리**

### **네트워크 애플리케이션의 목적**

- 네트워크를 통해 서로 통신하는 프로그램을 작성하는 것.
- 개발자는 애플리케이션 계층 외에는 신경 쓰지 않아도 된다.
- 네트워크 애플리케이션을 위한 통신은 **종단 시스템 간의 애플리케이션 계층**에서 발생한다.

---

### **네트워크 애플리케이션 구조**

- **클라이언트-서버 구조**
  - 네트워크 서비스를 요청하는 클라이언트와 응답을 하는 서버로 이루어짐.
  - 클라이언트는 항상 서버와 통신하며, 클라이언트끼리 통신하지 않음.
  - 서버는 **고정 IP**를 갖고, 클라이언트는 이를 통해 서비스 요청을 보냄.
  - **예:** 웹 서비스, 전자메일 서비스.
- **P2P 구조**
  - 특정 서버를 통하지 않고 피어가 통신.
  - 피어는 **클라이언트 또는 서버** 역할을 수행할 수 있음.
  - **예:** 파일 공유 서비스.

---

### **프로세스 간 통신**

- **통신 원리**  
  네트워크를 통한 메시지 교환은 **프로토콜 규칙**에 따라 이루어짐.  
  운영 체제는 이를 지원하는 **네트워크 인터페이스**와 **프로토콜 스택**을 제공.

- **소켓**

  - **정의:** 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스.
  - **역할:** 프로세스가 네트워크로 메시지를 주고받을 수 있게 함.
  - 애플리케이션과 네트워크 사이의 **API**.

- **프로세스 주소 배정**
  - 송신 프로세스는 **수신 프로세스의 주소**를 알아야 함.
  - 주소는 **호스트의 IP**와 **포트 번호**로 구성.
  - **포트 번호 예:** HTTP(80), SMTP(25).

---

### **애플리케이션이 이용 가능한 트랜스포트 서비스**

1. **신뢰적 데이터 전송**
   - 네트워크 내 패킷 손실 방지 및 순서 보장.
2. **처리율**

   - 네트워크가 단위 시간당 처리할 수 있는 데이터량(bps, Bps).
   - 처리율 보장 서비스가 필요한 애플리케이션 → **대역폭 민감 애플리케이션**.  
     반면, **탄력적 애플리케이션**은 가용한 처리율만 사용.

3. **시간**

   - 송신 데이터가 **특정 시간 내**에 도착하게 보장.

4. **보안**
   - 데이터 암호화(기밀성), 수신 호스트에서 해독.

---

### **인터넷 전송 프로토콜이 제공하는 서비스**

1. **TCP (Transmission Control Protocol)**

   - **특징:**
     - 연결지향형 서비스(3-way handshake).
     - 신뢰적인 데이터 전송(손실 및 순서 보장).
     - 혼잡 제어를 통해 네트워크 상태 조정.
   - **사용 사례:** HTTP, SMTP, FTP.

2. **UDP (User Datagram Protocol)**
   - **특징:**
     - 비연결형 서비스.
     - 비신뢰적(데이터 손실 및 순서 보장 X).
     - 빠르고 간단한 전송.
   - **사용 사례:** 스트리밍, 온라인 게임.

---

## **HTTP (HyperText Transfer Protocol)**

### **HTTP의 특징**

- **클라이언트-서버 프로토콜:** 클라이언트(브라우저)가 서버에 요청을 보내고 응답을 받음.
- **무상태(Stateless):** 서버가 클라이언트의 이전 요청 정보를 저장하지 않음.
- **비연결성(Connectionless):** 요청-응답 후 연결을 끊음.

### **HTTP 연결 방식**

1. **비지속 연결**

   - 요청-응답마다 새로운 TCP 연결 설정 및 종료.
   - HTTP/1.0.

2. **지속 연결**
   - 요청-응답 이후 TCP 연결 유지.
   - HTTP/1.1.

### **Cookie**

- HTTP의 무상태 특성을 보완하기 위한 수단.
- HTTP 헤더에 저장되어 전송.

---

## **Web Cache**

- **정의:** 웹 서버를 대신하여 HTTP 요청을 충족시키는 네트워크 개체.
- **역할:**
  - 최근 호출된 객체의 사본을 디스크에 저장 및 보존.
  - 클라이언트의 요청 시 캐시된 데이터를 반환.

### **이점**

1. 클라이언트의 요구에 대한 응답 시간 단축.
2. 네트워크 트래픽 감소로 링크 부담 완화.

### **Conditional GET**

- 캐싱 일관성을 보장하는 HTTP 전략.

1. 클라이언트가 `If-Modified-Since` 헤더에 이전 `Last-Modified` 값을 담아 요청.
2. 프록시 서버는 데이터 수정 여부 확인.
   - 변경 없음 → 캐시 데이터 반환(304 Not Modified).
   - 변경 있음 → 새로운 데이터 요청 및 업데이트.

---

## **DNS (Domain Name System)**

### **정의**

- **역할:** 호스트 이름 ↔ IP 주소 매핑.
- **구조:** 계층적으로 구현된 분산 데이터베이스.
- **사용 이유:** IP 주소보다 호스트 이름이 기억하기 쉬움.

### **DNS 아키텍처**

1. **루트 DNS 서버**

   - TLD 서버의 IP 주소 제공.
   - 전 세계 1000개 이상의 루트 서버 인스턴스.

2. **TLD (Top-Level Domain) 서버**

   - 상위 레벨 도메인(com, org, edu 등) 또는 국가 도메인(kr, uk, jp 등) 관리.
   - 권한 있는 DNS 서버의 IP 제공.

3. **Authoritative DNS 서버**

   - 호스트 이름 ↔ IP 주소 매핑.
   - DNS 계층의 마지막 서버(A 레코드만 존재).

4. **Local DNS 서버**
   - 클라이언트의 요청을 처리하며 프록시처럼 캐싱.

---

### **DNS Records**

- **구조:** name, value, type, TTL.
- **Type 예시:**
  - **A:** 호스트 이름 ↔ IP 주소.
  - **NS:** 도메인 ↔ 권한 있는 네임 서버.
  - **CNAME:** 호스트 이름 ↔ 호스트 별칭.
  - **MX:** 메일 서버 ↔ 별칭.

### **DNS Caching 및 TTL**

- DNS 서버는 응답 데이터를 캐싱하며 TTL 값에 따라 만료.
- 특정 호스트의 IP 주소 변경 시 Authoritative DNS의 A 레코드만 수정하면 됨.

---

### **DNS의 트랜스포트 프로토콜**

- **UDP 기반:** 빠르고 데이터 유실 가능성이 작음.
- 특정 상황(예: 영역 전송)에서는 **TCP**를 사용.
